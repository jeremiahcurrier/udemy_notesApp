app.js

	console.log('Starting app.js')

	const fs = require('fs')
	const os = require('os')
	const _ = require('lodash')
	const notes = require('./notes.js')

	var filteredArray = _.uniq(['Jeremiah', 'Jeremiah', 1, 1, 2, 3, 4, 5])
	console.log(filteredArray)

	/* Jeremiah from Slack joining.
	My name is Jeremiah and my role of Technical Architect owns all technical guidance from Slack for the duration of this engagement.
	I'm here to remove any technical roadblocks that come up as well as to deliver on any custom integrations built on the Slack platform.
	I've been a consultant for a couple years with the last 6 months being here at Slack.
	I've been developing on the Slack platform for 6 months.
	That will be the topic of the next video i am super excited to get started.
	*/



	// // var res = notes.addNote() // res could refer to 'result' or 'response'
	// // console.log(res)
	// console.log('Result:', notes.add(9, -2))

	// var user = os.userInfo()

	// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`, function(err) { // es6!
	// 	if (err) {
	// 		console.log('Unable to write to file')
	// 	}
	// })

	/*
	Progress
	1. modules included automatically (os, fs, http, etc)
	2. modules I created (notes.js)
	Next step
	3. 3rd party modules
	Why? Don't recreate the wheel with common utility functions
	NPM = node package manager (but also now has react and jquery so more than node packages)

	All projects:
	create project folder
	git clone (if pull from remote) OR npm init (fresh app)
	npm install

	should always be a package.json file
	npm install {module} --save
	--save will update the contents of the package.json file
	*/

	// Install module > validate you can do what you need RTFM
	/* order of operations is important in terms of finding the module and returning its exports
	1 = look in core modules
	2 = look in node_modules folder or project root
	3 = look for a module you built */
	// never touch or commit (to github et al) node_modules
	/* npm install without any flags will:
	(1) look at package.json file then
	(2) install depedencies
	*/

	// download .zip of app > unzip > go into project 'npm install' > start app

	// console.log(_.isString(true))
	// // console.log(_.isString('Jeremiah'))
	// var filteredArray = _.uniq(['Jeremiah', 'Jeremiah', 1, 1, 2, 3, 4])
	// console.log(filteredArray)


	/* automatically restart app as make changes to file
	 using a CLI utility which is an npm module called:
	 nodemon.
	 
	 'lodash' got added into package.json, added to node_modules
	 and required in app.js file
	 	'npm install lodash --save'

	 'nodemon' is a CLI utility executed from ternimal.
	 To install modules TO BE RUN FROM COMMAND LINE we have to
	 tweak install (can run CLI utility anywhere on screen)
		'npm install nodemon -g'

			 installs nodemon as a global utility ON YOUR MACHINE 
			 never requiring this npm package
			 never added to your specific project
	 */





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////









notes.js

	console.log('Starting notes.js')

	// console.log(module)

	/*
	exports is an 'object' on the 'module' property
	everything on the exports object gets exported and set as the variable in var foo = require('./example.js')
	*/

	/* define an 'age' property which will
	be a property set on 'notes' (the var set to this module)
	which we can use in app.js file
	*/
	// module.exports.age = 32
	// goal is to export functions that can be used in app.js


	// // anonymous function (ES5)
	// function sayHi(greeting) {
	// 	return greeting;
	// }
	// sayHi('Hello!');
	// // 'Hello!''

	// // anonymous function (ES6)
	// (greeting) => {
	// 	return greeting
	// }
	// // arrow function doesn't bind the 'this' keyword or the 'arguments' array
	/*
	In the nutshell, Object in JavaScript is just key-value pairs stored in a Hash.
	The difference between property and method is that --
	property is a value stored in the hash key,
	whereas method is a function stored in hash key.
	*/

	// code so we can return this in an export 
		// es5 anonymous function
	// module.exports.addNote = function () {
	// 	// code
	// }
	// module.exports.addNote = () => {
	// 	// code
	// }

	module.exports.addNote = () => {
	console.log('addNote')
	return 'New note'
	}

	// // 'exports' is an object so it can have multiple properties i.e. addNote and add and so on.
	// module.exports.add = function(a,b) {
	// 	return a + b
	// }

	module.exports.add = (a, b) => {
	return a + b
	}


















console.log('Starting app.js')

const fs = require('fs')
const _ = require('lodash')

const notes = require('./notes.js')
// you can initialize an app with a command line / CLI argument
// nothing breaks if you include n+ CLI arguments
// you can access them with the app you just initialized

// use process object (process and module are your friends) to access 
// the arguments your app was initialzied with

var command = process.argv[2] // must be 2 since the 0 = node and 1 = start file 'app.js'
console.log('Command: ', command)
console.log(process.argv) // argv is array of all CLI passed in

/*  node app.js remove --title=secrets
	node app.js remove --title="secrets"
	node app.js remove --title "secrets 2"
		(single quotes works on linux/mac WINDOWS needs doubles)
passes 'remove' argument to process (our app i.e. initializes our app with 'remove' as arg)
also includes 'title' argument with a value 'secrets' (title of the note to remove in this case)
*/

// PARSING COMMAND LINE ARGUMENTS IS A 'PITA' - luckily there is a module for this

if (command === 'add') {
	console.log('Adding new note')
} else if (command === 'list') {
	console.log('Listing all notes')
} else if (command === 'read') {
	console.log('Reading note')
} else if (command === 'remove') {
	console.log('Removing note')
} else {
	console.log('Command not recognized')
}

// switch (command) {
// 	case 'add':
// 		console.log('Adding new note')
// 		break
// 	case 'list':
// 		console.log('Listing all notes')
// 		break
// 	case 'read':
// 		console.log('Reading note')
// 		break
// 	case 'remove':
// 		console.log('Removing note')
// 		break
// 	default:
// 		console.log('Command not recognized')
// 		break
// }












notes.js

// module.exports.addNote = () => {
// 	console.log('addNote')
// 	return 'New note'
// }










console.log('Starting notes.js')

var addNote = (title, body) => {
	console.log('Adding note', title, body)
}

var getAll = () => {
	console.log('Getting all notes')
}

module.exports = {
	addNote,
	getAll
}

module.exports = {
	addNote: addNote,
	getAll: getAll
}










console.log('Starting notes.js')

var addNote = (title, body) => {
	console.log('Adding note', title, body)
}

/* In past we added properties onto the 'exports' object
   to export them (meaning exporting the value of a new key
   added to the 'exports' OBJECT)...

   we can actually define an entire object that is set to 'exports'

module.exports = {
	addNote: addNote // the function defined above
}

  ...in es6 if setting object attribute and a
  value that's a variable and they're
  both exactly the same you can leave off the ': value' */

module.exports = {
	addNote
}

































app.js

	console.log('Starting app.js')

	const fs = require('fs')
	const _ = require('lodash')
	const yargs = require('yargs')

	const notes = require('./notes.js')


	const argv = yargs.argv
	var command = process.argv[2] // must be 2 since the 0 = node and 1 = start file 'app.js'
	console.log('Command: ', command)
	// console.log('Process', process.argv) // argv is array of all CLI passed in
	console.log('Yargs', argv)

	if (command === 'add') {
		notes.addNote(argv.title, argv.body)
	} else if (command === 'list') {
		notes.getAll()
	} else if (command === 'read') {
		notes.getNote(argv.title)
	} else if (command === 'remove') {
		notes.removeNote(argv.title)
	} else {
		console.log('Command not recognized')
	}








console.log('Starting app.js')

const fs = require('fs')
const _ = require('lodash')
const yargs = require('yargs')

const notes = require('./notes.js')


const argv = yargs.argv
var command = process.argv[2] // must be 2 since the 0 = node and 1 = start file 'app.js'
console.log('Command: ', command)
// console.log('Process', process.argv) // argv is array of all CLI passed in
console.log('Yargs', argv)

if (command === 'add') {
	notes.addNote(argv.title, argv.body)
} else if (command === 'list') {
	notes.getAll()
} else if (command === 'read') { // title
	console.log('Reading note')
} else if (command === 'remove') { // title
	console.log('Removing note')
} else {
	console.log('Command not recognized')
}






/////////////////////////////////////////////
Section 3 Lecture 18: Working with JSON
/////////////////////////////////////////////

app.js

	//

notes.js

	//





./playground

json.js
	// var obj = {
	// 	name: 'Jeremiah'
	// }
	// // what if we want to do something with it? save to server/DB etc?
	// var stringObj = JSON.stringify(obj)
	// console.log(typeof stringObj)
	// console.log(stringObj)


	/* why set equal to string as single quotes? 
	because JSON uses double quotes in it so wrap with single quotes
	around the JSON
	*/
	/*
	var personString = '{"name": "Jeremiah", "age": 32}'
	// need to get from server then convert back to object
	// deserialize
	var person = JSON.parse(personString) // converts JSON string to original form
	// in this case original form is an object
	// prove it!
	console.log(typeof person)
	console.log(person)
	*/

	// next step?
	/* store string in file > read contents of file back
	*/

	const fs = require('fs')

	// when someone wants to SAVE a note
		// define obj to store in file and read back and parsed
	var originalNote = {
		title: 'Some title',
		body: 'Some body'
	}
		// originalNoteString and set to JSON value of object above
	var originalNoteString = JSON.stringify(originalNote)
		// write file into ./playground folder
	fs.writeFileSync('notes.json', originalNoteString)



	// when someone wants to read a note
		// read out contents > parse > print one of properties to screen (console)
	var noteString = fs.readFileSync('notes.json')
		// note
	var note = JSON.parse(noteString)
	console.log(typeof note)
	console.log(note.title)


notes.json

{"title":"Some title","body":"Some body"}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 19: Adding and saving notes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

notes.js

	try {
		// code that might have problems
		// files doesn't exist yet
		// file has bad data
		// and so on
	} catch (e) {
		// this runs if and only if the file above actually has a problem
	}

...

notes.js

	...
	
	var addNote = (title, body) => {
		var notes = []
		var note = {
			title,
			body
		}

		try {
			var notesString = fs.readFileSync('notes-data.json')
			notes = JSON.parse(notesString)

		} catch (e) {
			
		}

		// store notes in array with a title that already exists
		var duplicateNotes = notes.filter((note) => {
			/* .filter() is an array method that takes a callback
			https://alligator.io/js/filter-array-method/
			.filter(callback)
			.filter( () => {})
			call the callback function with the argument
			in this case the singular version
			an individual 'note'
			called once for every item in the array
			for each item - if return true include in new array
			for each item - if return false exclude in new array
			*/
			return note.title === title
		})

		notes.push(note)
		fs.writeFileSync('notes-data.json', JSON.stringify(notes))
	}
	
	...

		module.exports = {
			addNote,
			getAll,
			getNote,
			removeNote
		}


notes.js

	...

	// original
	var duplicateNotes = notes.filter((note) => {
		return note.title === title
	})

	// spicy (+ arrow functions) you can remove curly braces IF ONLY ONE STATEMENT
	var duplicateNotes = notes.filter((note) => note.title === title)

	...


notes.js

	var addNote = (title, body) => {
		var notes = [];
		var note = {
			title,
			body
		};

		try {
			var notesString = fs.readFileSync('notes-data.json')
			notes = JSON.parse(notesString)
		} catch (e) {
			
		}

		var duplicateNotes = notes.filter((note) => note.title === title);

		if (duplicateNotes.length === 0) {
			notes.push(note);
			fs.writeFileSync('notes-data.json', JSON.stringify(notes));
		}
	};





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 20: Refactoring for reusability
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

app.js

	console.log('Starting app.js');

	const fs = require('fs');
	const _ = require('lodash');
	const yargs = require('yargs');

	const notes = require('./notes.js');


	// console.log('Process', process.argv) // argv is array of all CLI passed in
	const argv = yargs.argv;
	// var command = process.argv[2]
	var command = argv._[0];
	console.log('Command: ', command);
	console.log('Yargs', argv);

	if (command === 'add') {
		var note = notes.addNote(argv.title, argv.body);
		// notes.addNote(argv.title, argv.body)
	} else if (command === 'list') {
		notes.getAll();
	} else if (command === 'read') {
		notes.getNote(argv.title);
	} else if (command === 'remove') {
		notes.removeNote(argv.title);
	} else {
		console.log('Command not recognized');
	}

	/* store user input? as JSON
	a way to represent JavaScript arrays and objects using a string 
	can save JSON to text file > read it later > parse it > and do
	something with is */

notes.js

	console.log('Starting notes.js');

	const fs = require('fs');

	var fetchNotes = () => {
		// arrow function, no arguments, fetching notes from filesystem
		try {
			var notesString = fs.readFileSync('notes-data.json')
			// notes = JSON.parse(notesString) // saves to 'notes' array
			return JSON.parse(notesString); // return to calling function
		} catch (e) {
			// no notes bc maybe no file or bad data i.e. not JSON
			return [];

		}
	};
	var saveNotes = (notes) => {
		// arrow function, takes an argument
		fs.writeFileSync('notes-data.json', JSON.stringify(notes));
	}

	var addNote = (title, body) => {
		// var notes = [];
		var notes = fetchNotes();
		var note = {
			title,
			body
		};
		var duplicateNotes = notes.filter((note) => note.title === title);

		if (duplicateNotes.length === 0) {
			notes.push(note);
			saveNotes(notes); // get in habit of creating re-usable functions
			return note; // returned to whoever called addNote in this case app.js
		}
	};

	var getAll = () => {
		console.log('Getting all notes')
	};

	var getNote = (title) => {
		console.log('Getting note', title)
	};

	var removeNote = (title) => {
		console.log('Removing note', title)
	};

	module.exports = {
		addNote,
		getAll,
		getNote,
		removeNote
	};



app.js

	console.log('Starting app.js');

	const fs = require('fs');
	const _ = require('lodash');
	const yargs = require('yargs');

	const notes = require('./notes.js');


	// console.log('Process', process.argv) // argv is array of all CLI passed in
	const argv = yargs.argv;
	// var command = process.argv[2]
	var command = argv._[0];
	console.log('Command: ', command);
	console.log('Yargs', argv);

	if (command === 'add') {
		// notes.addNote(argv.title, argv.body)
		var note = notes.addNote(argv.title, argv.body);
		// if (_.isUndefined(note)) {
		// 	console.log('Note already exists named: ', `${command}`);
		// } else {
		// 	console.log('Created note named: ', `${command}`); // template strings
		// }
		if (note) {
			console.log('Note created');
			console.log('--');
			console.log(`Title: ${note.title}`);
			console.log(`Body: ${note.body}`);
		} else {
			console.log('Note title taken');
		}
		
	} else if (command === 'list') {
		notes.getAll();
	} else if (command === 'read') {
		notes.getNote(argv.title);
	} else if (command === 'remove') {
		notes.removeNote(argv.title);
	} else {
		console.log('Command not recognized');
	}

	/* store user input? as JSON
	a way to represent JavaScript arrays and objects using a string 
	can save JSON to text file > read it later > parse it > and do
	something with is */























///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 21: Removing a note
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

'app.js'

	console.log('Starting app.js');

	const fs = require('fs');
	const _ = require('lodash');
	const yargs = require('yargs');

	const notes = require('./notes.js');

	const argv = yargs.argv;
	var command = argv._[0];
	console.log('Command: ', command);
	console.log('Yargs', argv);

	if (command === 'add') {
		var note = notes.addNote(argv.title, argv.body);
		if (note) {
			console.log('Note created');
			console.log('--');
			console.log(`Title: ${note.title}`);
			console.log(`Body: ${note.body}`);
		} else {
			console.log('Note title taken');
		}
		
	} else if (command === 'list') {
		notes.getAll();
	} else if (command === 'read') {
		notes.getNote(argv.title);
	} else if (command === 'remove') {
		var noteRemoved = notes.removeNote(argv.title); // either true or false
		var message = noteRemoved ? 'Note was removed' : 'Note not found';
		console.log(message);
	} else {
		console.log('Command not recognized');
	}


'notes.js'

	console.log('Starting notes.js');

	const fs = require('fs');

	var fetchNotes = () => {
		try {
			var notesString = fs.readFileSync('notes-data.json')
			return JSON.parse(notesString);
		} catch (e) {
			return [];

		}
	};
	var saveNotes = (notes) => {
		fs.writeFileSync('notes-data.json', JSON.stringify(notes));
	}

	var addNote = (title, body) => {
		var notes = fetchNotes();
		var note = {
			title,
			body
		};
		var duplicateNotes = notes.filter((note) => note.title === title);

		if (duplicateNotes.length === 0) {
			notes.push(note);
			saveNotes(notes);
			return note;
		}
	};

	var getAll = () => {
		console.log('Getting all notes')
	};

	var getNote = (title) => {
		console.log('Getting note', title)
	};

	var removeNote = (title) => {
		var notes = fetchNotes();
		// returns array of notes that DO NOT match the title passed in
		var filteredNotes = notes.filter((note) => note.title !== title);
		saveNotes(filteredNotes);
		// if removeNote returns 'true' means a note was removed
		/* if removeNote returns 'false'
		then notes and filteredNotes are equal
		nothing was removed
		*/
		return notes.length !== filteredNotes.length;
	};

	module.exports = {
		addNote,
		getAll,
		getNote,
		removeNote
	};











///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 22: Reading notes and reusability
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


app.js (WET)

		console.log('Starting app.js');

		const fs = require('fs');
		const _ = require('lodash');
		const yargs = require('yargs');

		const notes = require('./notes.js');

		const argv = yargs.argv;
		var command = argv._[0];
		console.log('Command: ', command);
		console.log('Yargs', argv);

		if (command === 'add') {
			var note = notes.addNote(argv.title, argv.body);
			if (note) {
				console.log('Note created');
				console.log('--');
				console.log(`Title: ${note.title}`);
				console.log(`Body: ${note.body}`);
			} else {
				console.log('Note title taken');
			}
			
		} else if (command === 'list') {
			notes.getAll();
		} else if (command === 'read') {
			// notes.getNote(argv.title);
			var note = notes.getNote(argv.title);
			// do something with return value of .getNote()
			// returns 'note' obj if it finds it
			// returns 'undefined' if it does not find the 'note' obj
			if (note) { // if statement
				console.log('Note read');
				console.log('--');
				console.log(`Title: ${note.title}`);
				console.log(`Body: ${note.body}`);
			} else { // else clause
				console.log('Note not found');
			}
			// after you store the value do some console.logging like 'note read' and 'note not found'
		} else if (command === 'remove') {
			var noteRemoved = notes.removeNote(argv.title); // either true or false
			var message = noteRemoved ? 'Note was removed' : 'Note not found';
			console.log(message);
		} else {
			console.log('Command not recognized');
		}


app.js (DRY)


		console.log('Starting app.js');

		const fs = require('fs');
		const _ = require('lodash');
		const yargs = require('yargs');

		const notes = require('./notes.js');

		const argv = yargs.argv;
		var command = argv._[0];
		console.log('Command: ', command);
		console.log('Yargs', argv);

		if (command === 'add') {
			var note = notes.addNote(argv.title, argv.body);
			if (note) {
				console.log('Note created');
				notes.logNote(note);
			} else {
				console.log('Note title taken');
			}
			
		} else if (command === 'list') {
			notes.getAll();
		} else if (command === 'read') {
			// notes.getNote(argv.title);
			var note = notes.getNote(argv.title);
			// do something with return value of .getNote()
			// returns 'note' obj if it finds it
			// returns 'undefined' if it does not find the 'note' obj
			if (note) { // if statement
				console.log('Note found');
				notes.logNote(note);
			} else { // else clause
				console.log('Note not found');
			}
			// after you store the value do some console.logging like 'note read' and 'note not found'
		} else if (command === 'remove') {
			var noteRemoved = notes.removeNote(argv.title); // either true or false
			var message = noteRemoved ? 'Note was removed' : 'Note not found';
			console.log(message);
		} else {
			console.log('Command not recognized');
		}




notes.js (WET)

		console.log('Starting notes.js');

		const fs = require('fs');

		var fetchNotes = () => {
			try {
				var notesString = fs.readFileSync('notes-data.json')
				return JSON.parse(notesString);
			} catch (e) {
				return [];

			}
		};
		var saveNotes = (notes) => {
			fs.writeFileSync('notes-data.json', JSON.stringify(notes));
		}

		var addNote = (title, body) => {
			var notes = fetchNotes();
			var note = {
				title,
				body
			};
			var duplicateNotes = notes.filter((note) => note.title === title);

			if (duplicateNotes.length === 0) {
				notes.push(note);
				saveNotes(notes);
				return note;
			}
		};

		var getAll = () => {
			console.log('Getting all notes')
		};

		var getNote = (title) => {
			// console.log('Getting note', title)
			
			// fetch the notes
			var notes = fetchNotes();
			// use notes.filter to only return notes
			// whose title matches that in title argument
			// either 0 notes = note not found
			// OR 1 note = found note
				// var filteredNotes = notes.filter((note) => {
				// 	return note.title === title;
				// });
			// you are only 'returning' one line so you can simplify:
			var filteredNotes = notes.filter((note) => note.title === title);
			// .filter() method takes a function 
				// method is function on exports object
				// property is value of key on exports object
			// return the note (the first item in the array)
			return filteredNotes[0] // should be 1 item or 'undefined'
			// should be 3 lines of code
			// test with note title does not exist and one where note does exist
		};

		var removeNote = (title) => {
			var notes = fetchNotes();
			// returns array of notes that DO NOT match the title passed in
			var filteredNotes = notes.filter((note) => note.title !== title);
			saveNotes(filteredNotes);
			// if removeNote returns 'true' means a note was removed
			/* if removeNote returns 'false'
			then notes and filteredNotes are equal
			nothing was removed
			*/
			return notes.length !== filteredNotes.length;
		};

		module.exports = {
			addNote,
			getAll,
			getNote,
			removeNote
		};



notes.js (DRY)


		console.log('Starting notes.js');

		const fs = require('fs');

		var fetchNotes = () => {
			try {
				var notesString = fs.readFileSync('notes-data.json')
				return JSON.parse(notesString);
			} catch (e) {
				return [];

			}
		};
		var saveNotes = (notes) => {
			fs.writeFileSync('notes-data.json', JSON.stringify(notes));
		}

		var addNote = (title, body) => {
			var notes = fetchNotes();
			var note = {
				title,
				body
			};
			var duplicateNotes = notes.filter((note) => note.title === title);

			if (duplicateNotes.length === 0) {
				notes.push(note);
				saveNotes(notes);
				return note;
			}
		};

		var getAll = () => {
			console.log('Getting all notes')
		};

		var getNote = (title) => {
			var notes = fetchNotes();
			var filteredNotes = notes.filter((note) => note.title === title);
			return filteredNotes[0]
		};

		var removeNote = (title) => {
			var notes = fetchNotes();
			var filteredNotes = notes.filter((note) => note.title !== title);
			saveNotes(filteredNotes);
			return notes.length !== filteredNotes.length;
		};

		var logNote = (note) => {
			console.log('--');
			console.log(`Title: ${note.title}`);
			console.log(`Body: ${note.body}`);
		};

		module.exports = {
			addNote,
			getAll,
			getNote,
			removeNote,
			logNote // using es6 syntax where logNote: logNote is es5
		};










///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 20/21: Debugging
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


playground/debugging.js


	var person = {
		name: 'Jeremiah'
	};

	person.age = 32;

	person.name = 'Jerry';

	console.log(person);

with debug mode on 

$ node inspect playground/debugging.js








///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 22: Listing notes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


app.js (BEFORE)

		console.log('Starting app.js');

		const fs = require('fs');
		const _ = require('lodash');
		const yargs = require('yargs');

		const notes = require('./notes.js');

		const argv = yargs.argv;
		var command = argv._[0];
		console.log('Command: ', command);
		console.log('Yargs', argv);

		if (command === 'add') {
			var note = notes.addNote(argv.title, argv.body);
			if (note) {
				console.log('Note created');
				notes.logNote(note);
			} else {
				console.log('Note title taken');
			}
			
		} else if (command === 'list') {
			// notes.getAll();
			var allNotes = notes.getAll();
			console.log(`Printing ${allNotes.length} notes(s).`);
			// // how do we call logNote() for each note?
			/* ...we can call .forEach() on 'allNotes'
			(where the returned value is...
			  the return statement of calling .getAll() 
			  ... on the notes variable) 
			  which takes a function. We can use an arrow function.
			*/
			// allNotes.forEach((note) => {
			// 	// code
			// 	notes.logNote(note)
			// });
			// simplified:
			allNotes.forEach((note) => notes.logNote(note));
		} else if (command === 'read') {
			// notes.getNote(argv.title);
			var note = notes.getNote(argv.title);
			// do something with return value of .getNote()
			// returns 'note' obj if it finds it
			// returns 'undefined' if it does not find the 'note' obj
			if (note) { // if statement
				console.log('Note found');
				notes.logNote(note);
			} else { // else clause
				console.log('Note not found');
			}
			// after you store the value do some console.logging like 'note read' and 'note not found'
		} else if (command === 'remove') {
			var noteRemoved = notes.removeNote(argv.title); // either true or false
			var message = noteRemoved ? 'Note was removed' : 'Note not found';
			console.log(message);
		} else {
			console.log('Command not recognized');
		}




app.js (AFTER)


		const fs = require('fs');
		const _ = require('lodash');
		const yargs = require('yargs');

		const notes = require('./notes.js');

		const argv = yargs.argv;
		var command = argv._[0];

		if (command === 'add') {
			var note = notes.addNote(argv.title, argv.body);
			if (note) {
				console.log('Note created');
				notes.logNote(note);
			} else {
				console.log('Note title taken');
			}
			
		} else if (command === 'list') {
			var allNotes = notes.getAll();
			console.log(`Printing ${allNotes.length} notes(s).`);
			allNotes.forEach((note) => notes.logNote(note));
		} else if (command === 'read') {
			var note = notes.getNote(argv.title);
			if (note) { // if statement
				console.log('Note found');
				notes.logNote(note);
			} else { // else clause
				console.log('Note not found');
			}
		} else if (command === 'remove') {
			var noteRemoved = notes.removeNote(argv.title); // either true or false
			var message = noteRemoved ? 'Note was removed' : 'Note not found';
			console.log(message);
		} else {
			console.log('Command not recognized');
		}




notes.js (BEFORE)


		console.log('Starting notes.js');

		const fs = require('fs');

		var fetchNotes = () => {
			try {
				var notesString = fs.readFileSync('notes-data.json')
				return JSON.parse(notesString);
			} catch (e) {
				return [];

			}
		};
		var saveNotes = (notes) => {
			fs.writeFileSync('notes-data.json', JSON.stringify(notes));
		}

		var addNote = (title, body) => {
			var notes = fetchNotes();
			var note = {
				title,
				body
			};
			var duplicateNotes = notes.filter((note) => note.title === title);

			if (duplicateNotes.length === 0) {
				notes.push(note);
				saveNotes(notes);
				return note;
			}
		};

		var getAll = () => {
			// console.log('Getting all notes')
			return fetchNotes();
		};

		var getNote = (title) => {
			var notes = fetchNotes();
			var filteredNotes = notes.filter((note) => note.title === title);
			return filteredNotes[0]
		};

		var removeNote = (title) => {
			var notes = fetchNotes();
			var filteredNotes = notes.filter((note) => note.title !== title);
			saveNotes(filteredNotes);
			return notes.length !== filteredNotes.length;
		};

		var logNote = (note) => {
			console.log('--');
			console.log(`Title: ${note.title}`);
			console.log(`Body: ${note.body}`);
		};

		module.exports = {
			addNote,
			getAll,
			getNote,
			removeNote,
			logNote // using es6 syntax where logNote: logNote is es5
		};


notes.js (AFTER)


		const fs = require('fs');

		var fetchNotes = () => {
			try {
				var notesString = fs.readFileSync('notes-data.json')
				return JSON.parse(notesString);
			} catch (e) {
				return [];

			}
		};
		var saveNotes = (notes) => {
			fs.writeFileSync('notes-data.json', JSON.stringify(notes));
		}

		var addNote = (title, body) => {
			var notes = fetchNotes();
			var note = {
				title,
				body
			};
			var duplicateNotes = notes.filter((note) => note.title === title);

			if (duplicateNotes.length === 0) {
				notes.push(note);
				saveNotes(notes);
				return note;
			}
		};

		var getAll = () => {
			return fetchNotes();
		};

		var getNote = (title) => {
			var notes = fetchNotes();
			var filteredNotes = notes.filter((note) => note.title === title);
			return filteredNotes[0]
		};

		var removeNote = (title) => {
			var notes = fetchNotes();
			var filteredNotes = notes.filter((note) => note.title !== title);
			saveNotes(filteredNotes);
			return notes.length !== filteredNotes.length;
		};

		var logNote = (note) => {
			console.log('--');
			console.log(`Title: ${note.title}`);
			console.log(`Body: ${note.body}`);
		};

		module.exports = {
			addNote,
			getAll,
			getNote,
			removeNote,
			logNote // using es6 syntax where logNote: logNote is es5
		};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 23: Requiring Arguments and Advanced Yargs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


.command























///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Section 3 Lecture 24: Arrow functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


es5 function VS es6 'arrow' function



/* Arrow functions do not bind the 'this' keyword
...so if you're using 'this' in your function
it will not work when you use an arror function.
*/

// arrow function - STATEMENT syntax
// var square = (x) => {
// 	// code
// 	var result = x*x;
// 	return result;
// };

// arrow function - EXPRESSION syntax (1 argument)
var square = x => x * x;

// // arrow function - EXPRESSION syntax (0 or 2+ arguments)
// var square = () => {};
// var square = (x,y) => {};
// var square = (x,y,z) => {};

console.log(square(9));

var user = {
	name: 'Jeremiah',
	sayHi: () => {
		// console.log(`Hi`);
		console.log(arguments);
		console.log(`Hi. I'm ${this.name}`); // Hi, I'm undefined (bc 'this' keyword does not get bound)
		// console.log(`Hi. I'm ${user.name}`); // Hi, I'm Jeremiah
	},
	/* alt syntax in es6 great when defining 'object literals'
	 es6 provides new way to make methods on objects
	 no need for function keyword
	 object literal === "comma-separated list of name-value pairs wrapped in curly braces"
	 i.e. 
		var myObject = {
		    sProp: 'some string value',
		    numProp: 2,
		    bProp: false
		};
	ES6 provides new way to make methods on objects
	 you provide the method name 'sayHiAlt' then you go right
	 to the parantheses skipping the : colon
	*/
	sayHiAlt () {
		console.log(arguments);
		/* 'arguments' !== an actual array
		...more like an object with array-like properties
		the 'arguments' object will format all arguments
		into name:value pairs in an object
		i.e.
			user.sayHiAlt(1, 2, 3);
		prints
			[Arguments] { '0': 1, '1': 2, '2': 3 }
		*/
		console.log(`Hi. I'm ${this.name}`); // Hi, I'm undefined
	}
};

// user.sayHi();

/* will return the special 'arguments' keyword + 'this' binding */ 
user.sayHiAlt(1, 2, 3);

/* will return GLOBAL arguments variable i.e. require, module, etc */
// user.sayHi(1, 2, 3);



/* USE CASE review:
When you try to create methods on an object and use arrow functions
switch

...from this syntax:

	var foo = {
		sayHi: () => {
			console.log(arguments);
			console.log(`Hi. I'm ${this.name}`);
		}
	}

...to  this syntax:

	var foo = {
		sayHi () {
			console.log(arguments);
			console.log(`Hi. I'm ${this.name}`);
		}
	}

*/




















